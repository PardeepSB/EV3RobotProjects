#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

////////////////////////////////////////////
//                                        //
//             INITIALIZATION             //
//                                        //
////////////////////////////////////////////

//define size of array for use throughout code
#define size sizeof(arrDirec)/sizeof(arrDirec[0])


//Facing Direction N-0|E-1|S-2|W-3       //
int startrobHeading = 3;                 //IMPORTANT!!!
										 //
//Starting location                      //CHANGE robHeading, Start, and Target Variables
int startRow = 3;                        //if you want to go to different location
int startCol = 6;                        //
										 //
//Target location                        //
int targetRow = 5;                       //
int targetCol = 5;                       //

//Initialize robot row, column, heading based on input
int robHeading = startrobHeading;
int robRow = startRow;
int robCol = startCol;

//Incremented values
int bestIncrement = 0;
int physIncrement = 0;
int numDirec = 0;
int arrayLoc = 0;

//save current physical robot column, row, and line length
int physicalCol = startCol;
int physicalRow = startRow;
int physicalCellLength = 395;

//Initialize Arrays
char arrDirec[200];
int arrGryo[100];

//Initializing number of rows & columns and size of screen
const int numOfRows = 8;
const int numOfCols = 10;
float screenWidth = 177;
float screenHeight = 127;
float	cellWidth = screenWidth/9;
float	cellHeight = screenHeight/7;

//Struct containing all the lines at a cell locations
struct mazeCell{
	int Nline;
	int Eline;
	int Sline;
	int Wline;
}

struct mazeCell Maze[numOfRows][numOfCols];


/*
typedef struct{
	int Nline;
	int Eline;
	int Sline;
	int Wline;
} cell;

cell Maze[numOfRows][numOfCols];


*/

//Calling all functions
void initializeMaze();
void defineMaze();
void simulateMaze();
void refreshScreen();
void drawBot();
void turnRight();
void turnLeft();
void goFwd();
void rwFollow();
void bestPath(char *arr);
void followBest();
void LineTrack();
void physicalFollow(char *arr);
void rotate(int *arrGryo, int currentCellPos);
void LocSave(int loc);
void findNumDirec();


printf(".2%f", 5) 5.00
/////////////////////////////////////////////
//                                         //
//     Executing all functions in MAIN     //
//                                         //
/////////////////////////////////////////////

task main()
{
	//Display maze and solve best path in Maze
	refreshScreen();
	initializeMaze();
	defineMaze();
	simulateMaze();
	rwFollow();
	bestPath(arrDirec);

	//Play sound to inform of start
	playSoundFile("Start");

	//Save turn values (0,90,-90) in array based on directions
	physicalFollow(arrDirec);

	//Reset all values to begin Physical Robot maze solving
	robHeading = startrobHeading;
 	robRow = startRow;
 	robCol = startCol;
	
	//Line track and turn appropriately based on best path
	resetGyro(gyroSensor);
	findNumDirec();
	for(int i = 0; i < numDirec; i++){
		LineTrack();
		rotate(arrGryo, i);
	}

	//Cheer to signify maze bring solved
	setSoundVolume(100);
	playSoundFile("Cheering");
	sleep(5000);
	playSoundFile("Thank you");
	sleep(5000);

	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);

}

/////////////////////////////////////////////
//                                         //
//       All Functions within system       //
//                                         //
/////////////////////////////////////////////


//Initialize maze
void initializeMaze(){
	for (int row = 0; row < numOfRows; row++){
		for (int col = 0; col < numOfCols; col++){
			Maze[row][col].Nline = 0;
			Maze[row][col].Eline = 0;
			Maze[row][col].Sline = 0;
			Maze[row][col].Wline = 0;
		}
	}
}


//Define maze lines (hard coded)
void defineMaze() {
		//row 1
		for (int i = 0; i<8; i++){
			Maze[2][i].Eline = Maze[2][i+1].Wline = 1;
		}

		//column 2
		for (int i = 1; i<7; i++){
			Maze[i][2].Nline = Maze[i+1][2].Sline = 1;
		}

		//column 7
		for (int i = 1; i<7; i++){
			Maze[i][7].Nline = Maze[i+1][7].Sline = 1;
		}

		//row 0
		Maze[1][1].Eline = Maze[1][2].Wline = 1;
		Maze[1][2].Eline = Maze[1][3].Wline = 1;
		Maze[1][3].Eline = Maze[1][4].Wline = 1;
		Maze[1][6].Eline = Maze[1][7].Wline = 1;
		Maze[1][8].Nline = Maze[2][8].Sline = 1;

		//left side
		Maze[3][0].Eline = Maze[3][1].Wline = 1;
		Maze[3][1].Nline = Maze[4][1].Sline = 1;
		Maze[4][1].Eline = Maze[4][2].Wline = 1;

		for (int i = 0; i<5; i++){
			Maze[5][i].Eline = Maze[5][i+1].Wline = 1;
		}

		Maze[7][0].Eline = Maze[7][1].Wline = 1;
		Maze[7][1].Sline = Maze[6][1].Nline = 1;
		Maze[6][1].Eline = Maze[6][2].Wline = 1;

		Maze[4][4].Nline = Maze[5][4].Sline = 1;
		Maze[5][4].Nline = Maze[6][4].Sline = 1;
		Maze[6][4].Eline = Maze[6][5].Wline = 1;
		Maze[6][5].Nline = Maze[7][5].Sline = 1;

		//column 6
		for (int i = 3; i<7; i++){
			Maze[i][6].Nline = Maze[i+1][6].Sline = 1;
		}

		//row 2
		for (int i = 3; i<6; i++){
			Maze[3][i].Eline = Maze[3][i+1].Wline = 1;
		}

		Maze[4][2].Eline = Maze[4][3].Wline = 1;
		Maze[3][3].Nline = Maze[4][3].Sline = 1;

		Maze[3][5].Nline = Maze[4][5].Sline = 1;

		Maze[5][7].Eline = Maze[5][8].Wline = 1;

		Maze[0][0].Eline = Maze[0][1].Wline = 1;
		Maze[0][4].Eline = Maze[0][5].Wline = 1;
		Maze[0][6].Eline = Maze[0][7].Wline = 1;
		Maze[0][7].Eline = Maze[0][8].Wline = 1;
		Maze[0][8].Eline = Maze[0][9].Wline = 1;

		Maze[2][8].Eline = Maze[2][9].Wline = 1;
		Maze[4][8].Eline = Maze[4][9].Wline = 1;
		Maze[5][8].Eline = Maze[5][9].Wline = 1;
		Maze[6][8].Eline = Maze[6][9].Wline = 1;

		Maze[0][1].Nline = Maze[1][1].Sline = 1;
		Maze[0][2].Nline = Maze[1][2].Sline = 1;
		Maze[0][4].Nline = Maze[1][4].Sline = 1;
		Maze[0][6].Nline = Maze[1][6].Sline = 1;

		Maze[4][9].Nline = Maze[5][9].Sline = 1;
		Maze[5][9].Nline = Maze[6][9].Sline = 1;
		Maze[3][8].Nline = Maze[4][8].Sline = 1;

}


//Simulate maze based on defined lines and size of each cell
void simulateMaze(){
	for (int row = 0; row < numOfRows; row++){
		for (int col = 0; col < numOfCols; col++){
			if(Maze[row][col].Nline == 1){
				drawLine(cellWidth*col, cellHeight*row, cellWidth*col, cellHeight*(row+1));
			}
			if(Maze[row][col].Eline == 1){
				drawLine(cellWidth*col, cellHeight*row, cellWidth*(col+1), cellHeight*row);
			}
			if(Maze[row][col].Sline == 1){
				drawLine(cellWidth*col, cellHeight*row, cellWidth*col, cellHeight*(row-1));
			}
			if(Maze[row][col].Wline == 1){
				drawLine(cellWidth*col, cellHeight*row, cellWidth*(col-1), cellHeight*row);
			}
		}
	}
}


//Right Wall follow used to follow the right wall of the maze
void rwFollow(){
	//Loop continues until the target location is reached
	while((robRow != targetRow) || (robCol != targetCol)){

		//Switch statement for all facing directions
		switch(robHeading){
			case 0:																						//Facing North
				//If a line is seen to the right of its current direction, turn right
				if(Maze[robRow][robCol].Eline == 1){
					turnRight();
					drawBot();
					break;
				}
				//If there is no line to its right, continue straight
				else if (Maze[robRow][robCol].Nline == 1){
					//dont turn
					break;
				}
				//If there is no line to its right or front, turn left
				else if (Maze[robRow][robCol].Wline == 1){
					turnLeft();
					drawBot();
					break;
				}
				//If there is no line for any direction in front or sides, turn 180deg
				else if (Maze[robRow][robCol].Sline == 1){
					turnLeft();
					turnLeft();
					drawBot();
					break;
				}
				break;

			case 1:																						//Facing East
				if(Maze[robRow][robCol].Sline == 1){
					turnRight();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Eline == 1){
					//dont turn
					break;
				}
				else if (Maze[robRow][robCol].Nline == 1){
					turnLeft();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Wline == 1){
					turnLeft();
					turnLeft();
					drawBot();
					break;
				}
				break;

			case 2:																						//Facing South
				if(Maze[robRow][robCol].Wline == 1){
					turnRight();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Sline == 1){
					//dont turn
					break;
				}
				else if (Maze[robRow][robCol].Eline == 1){
					turnLeft();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Nline == 1){
					turnLeft();
					turnLeft();
					drawBot();
					break;
				}
				break;


			case 3:                                           											//Facing West
			if(Maze[robRow][robCol].Nline == 1){
					turnRight();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Wline == 1){
					//dont turn
					break;
				}
				else if (Maze[robRow][robCol].Sline == 1){
					turnLeft();
					drawBot();
					break;
				}
				else if (Maze[robRow][robCol].Eline == 1){
					turnLeft();
					turnLeft();
					drawBot();
					break;
				}
				break;

			default: break;
		}
		//display following on LCD screen 
		//save directions N/E/S/W in global array
		goFwd();
		drawBot();
		LocSave(arrayLoc);
		arrayLoc++;
	}

	//Flash "Maze solved" on Dislay three times
	for(int i = 0; i < 3; i++){
		eraseDisplay();
		sleep(500);
		displayCenteredTextLine(3,"Maze Solved");
		sleep(500);
	}
	eraseDisplay();
}

//save directions based on robot heading (direction its facing)
void LocSave(int loc){
		if(robHeading == 0){
			arrDirec[loc] = 'N';
		}
		if(robHeading == 1){
			arrDirec[loc] = 'E';
		}
		if(robHeading == 2){
			arrDirec[loc] = 'S';
		}
		if(robHeading == 3){
			arrDirec[loc] = 'W';
		}
}

//Draw robot on display
void drawBot(){
	int RobotXpixelPos=0;
	int RobotYpixelPos=0;
	if(robCol==0){
		RobotXpixelPos=2;
	}
	else{
		RobotXpixelPos=robCol*cellWidth-2;
	}
	if(robRow==0){
		RobotYpixelPos=2;
	}
	else{
		RobotYpixelPos=robRow*cellHeight+2;
	}
	switch(robHeading){
	case 0: displayStringAt(RobotXpixelPos,RobotYpixelPos,"^"); wait1Msec(100);
	break; // Facing North
	case 1: displayStringAt(RobotXpixelPos,RobotYpixelPos,">"); wait1Msec(100);
	break; // Facing East
	case 2: displayStringAt(RobotXpixelPos,RobotYpixelPos,"V"); wait1Msec(100);
	break; // Facing South
	case 3: displayStringAt(RobotXpixelPos,RobotYpixelPos,"<"); wait1Msec(100);
	break; // Facing West
	default: break;
	}
}


//Turn robot right (virtual)
void turnRight(){
	if (robHeading < 3){
		robHeading++;
	}
	else robHeading=0;
}

//Turn robot left (virtual)
void turnLeft(){
	if (robHeading > 0){
		robHeading--;
	}
	else robHeading=3;
}


//Robot moves forward (virtually) on display depending on direction its facing
void goFwd(){
	wait1Msec(10); // waste some time to simulate motion
	if (robHeading==0) { // Going Fwd North
		robRow++;
	}
	else if (robHeading==1) { // Going Fwd East
		robCol++;
	}
	else if (robHeading==2) { // Going Fwd South
		robRow--;
	}
	else if (robHeading==3) { // Going Fwd West
		robCol--;
	}
	else {
		robRow = 99;
		robCol = 99;
	}
	refreshScreen();
}


//Refresh screen to display new changed position/direction
void refreshScreen(){
	eraseDisplay();
	defineMaze();
	simulateMaze();
	drawBot();
}



//Simplify saved right wall follow path to shortest/fastest possible path to solve maze
void bestPath(char *arr){
	int value1, value2;
	int increment = 0;

	//Simplify over the course of 10 loops
	for(int y = 0;y <= 50; y++){
		//Compare 2 values from path to check if they are redundant
		for(int i = 0;i < size-1; i++){
				value1 = arr[i];
				value2 = arr[i+1];
			//Save the element of the redundant values
			if((abs(value2-value1) == 18) || (abs(value2-value1) == 5)){
				arr[i] = 0;
				arr[i+1] = 0;
			}
		}
		//Shift all values to remove 0's
		for(int i = 0;i < size;i++){
			if(arr[i] != 0){
				arr[increment] = arr[i];
				increment++;
			}
		}
		//Set all values outside of saved values to 0
		for(int i = size; i >= increment; i--){
			arr[i] = 0;
		}
		//Reset variables for next loop of new array
		increment = 0;
	}
}

//Follow path (virtually) alongside the physical robot
void followBest(){
	switch(arrDirec[bestIncrement]){
		case 'N':
			robHeading = 0;
			drawBot();
			goFwd();
			break; // Facing North
		case 'E':
			robHeading = 1;
			drawBot();
			goFwd();
			break; // Facing East
		case 'S':
			robHeading = 2;
			drawBot();
			goFwd();
			break; // Facing South
		case 'W':
			robHeading = 3;
			drawBot();
			goFwd();
			break; // Facing West
		default: break;
	}
	bestIncrement++;
}

//find the number of values within the saved best path array (for loop in main)
void findNumDirec(){
	for(int i = 0; i < size; i++){
		if(arrDirec[i] != 0){
			numDirec++;
		}
	}
}


//Save current column and row position of robot
void physicalPos(){
	switch(arrDirec[physIncrement]){
		case 'N':
				physicalRow++;
			break; // Facing North
		case 'E':
				physicalCol++;
			break; // Facing East
		case 'S':
				physicalRow--;
			break; // Facing South
		case 'W':
				physicalCol--;
			break; // Facing West
		default: break;
	}
	physIncrement++;
}


//Right Line Tracking function
void LineTrack() {

	//update current position of physical robot
	physicalPos();
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);

	//for the distance of the line, move forward
	while(getMotorEncoder(leftMotor) < physicalCellLength){
		setMotorSpeed(leftMotor, 6);
		setMotorSpeed(rightMotor, 15);			//drift left

		//check if value is nearing edge case of yellow -> black intersections
		int correction = 0;
		if (arrDirec[bestIncrement] == 'W') {correction = 1;}

		//follow yellow line
		if(physicalCol > 4-correction){
			while(getColorReflected(colorSensor) > 30){
				setMotorSpeed(leftMotor, 25);
				setMotorSpeed(rightMotor, 10);
			}
		}

		//follow black line
		if(physicalCol <= 4-correction){
			while(getColorReflected(colorSensor) < 15){
				setMotorSpeed(leftMotor, 25);
				setMotorSpeed(rightMotor, 10);			//drift right
			}
		}

	}
	//move forward for an expected target value for robot to realign
	resetMotorEncoder(leftMotor);
	resetMotorEncoder(rightMotor);
	setMotorTarget(leftMotor, physicalCellLength-155, 20);
	setMotorTarget(rightMotor, physicalCellLength-155, 20);
	waitUntilMotorStop(leftMotor);
	followBest();
}


//Save gyro values for physical robot function "rotate" to apply
void physicalFollow(char *arr){
		for(int i = 0; i < size; i++){

			switch(arr[i]){
				case 'N':
					if(arr[i+1] == 'N'){
				//		driveStraight();
						arrGryo[i] = 0;
					}
					if(arr[i+1] == 'E'){
				//		rightLineTrack();
						arrGryo[i] = 90;
					}
					if(arr[i+1] == 'W'){
				//		leftLineTrack();
						arrGryo[i] = -90;
					}
				break; // Facing North
				case 'E':
					if(arr[i+1] == 'E'){
				//		driveStraight();
						arrGryo[i] = 0;
					}
					if(arr[i+1] == 'S'){
					//	rightLineTrack();
						arrGryo[i] = 90;
					}
					if(arr[i+1] == 'N'){
				//		leftLineTrack();
						arrGryo[i] = -90;
					}
				break; // Facing East
				case 'S':
					if(arr[i+1] == 'S'){
					//	driveStraight();
						arrGryo[i] = 0;
					}
					if(arr[i+1] == 'W'){
					//	rightLineTrack();
						arrGryo[i] = 90;
					}
					if(arr[i+1] == 'E'){
					//	leftLineTrack();
						arrGryo[i] = -90;
					}
				break; // Facing South
				case 'W':
					if(arr[i+1] == 'W'){
					//	driveStraight();
						arrGryo[i] = 0;
					}
					if(arr[i+1] == 'N'){
					//	rightLineTrack();
						arrGryo[i] = 90;
					}
					if(arr[i+1] == 'S'){
				//		leftLineTrack();
						arrGryo[i] = -90;
					}
				break; // Facing West
				default: break;
				}
		}
}


//rotate robot based on saved gyro values in arrGryo
void rotate(int *arrGryo, int currentCellPos){
	resetGyro(gyroSensor);
	if(arrGryo[currentCellPos] < 0){
		playSoundFile("Turn");
		playSoundFile("Left");
		sleep(1000);
		while(getGyroDegrees(gyroSensor) >= arrGryo[currentCellPos]){
			setMotorSpeed(leftMotor, -20);
			setMotorSpeed(rightMotor, 20);
		}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
	}
	if(arrGryo[currentCellPos] > 0){
		playSoundFile("Turn");
		playSoundFile("Right");
		sleep(1000);
		while(getGyroDegrees(gyroSensor) < arrGryo[currentCellPos]){
			setMotorSpeed(leftMotor, 20);
			setMotorSpeed(rightMotor, -20);
		}
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 0);
	}
	if(arrGryo[currentCellPos] == 0){
			//do nothing
	}
	sleep(1000);
}